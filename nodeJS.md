# 《深入浅出Node.js》

## Node简介

### Node的特点
作为后端JavaScript的运行平台，Node保留了前端浏览器JavaScript中那些熟悉的接口，没有改写语言本身的任何特性，依旧基于作用域和原型链，区别在于它将前端中广泛运用的思想迁移到了服务器端。

### Node的应用场景

- I/O密集型

    Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。

- CPU密集型业务

    关于CPU密集型应用，Node的异步I/O已经解决了在单线程上CPU与I/O之间阻塞无法重叠利用的问题，I/O阻塞造成的性能浪费远比CPU的影响小。对于长时间运行的计算，如果它的耗时超过普通阻塞I/O的耗时，那么应用场景就需要重新评估，因为这类计算比阻塞I/O还影响效率，甚至说就是一个纯计算的场景，根本没有I/O。此类应用场景或许应当采用多线程的方式进行计算。Node虽然没有提供多线程用于计算支持，但是还是有以下两个方式来充分利用CPU。

    + Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现。

    + 如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当作常驻服务进程用于计算，然后利用进程间的消息传递结果，将计算与I/O分离，这样还能充分利用多CPU。

### Node的使用者

- 前后端编程语言环境统一
- Node带来的高性能I/O用于实时应用
- 并行I/O使得使用者可以更高效地利用分布式环境
- 并行I/O，有效利用稳定接口提升Web渲染能力
- 云计算平台提供Node支持
- 游戏开发领域
- 工具类应用

## 模块机制

JavaScript的规范依然是薄弱的，还有以下缺点：
1. 没有模块系统
2. 标准库比较少
3. 没有标准接口
4. 缺乏包管理系统

CommonJS规范的提出，主要是为了弥补当前JavaScript没有标准的缺陷，以达到像Python、Ruby和Java具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段。他们期望那些用CommonJ API写出的应用可以具备跨宿主环境执行的能力，这样不仅可以利用JavaScript开发富客户端应用，而且还可以编写以下应用：
- 服务器端JavaScript应用程序
- 命令行工具
- 桌面图形界面应用程序
- 混合应用

### CommonJS的模块规范

> CommonJS对模块对定义十分简单，主要分为模块引用、模块定义和模块标识3个部分。


1. 模块引用

模块引用的示例代码：`var math = require('math');`

在CommonJS规范中，存在require()方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中。

2. 模块定义

在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式
```
// math.js
exports.add = function() {
    var sum = 0, i = 0, args = arguments, l = args.length;
    while(i < 1) {
        sum += args[i++];
    }
    return sum;
};
```
在另一个文件中，我们通过require()方法引入模块后，就能调用定义的属性或方法了：
```
// program.js
var math = require('math');
exports.increment = function(val) {
    return math.add(val, 1);
}
```

3. 模块标识

模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者.、..开头的相对路径，或者绝对路径。它可以没有文件后缀.js。

模块的定义十分简单，接口也十分简洁。它的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地链接上下游依赖。每个模块具有独立的空间，它们互不干扰，在引用时也显得干净利落。

CommonJS构建的这套模块导出和引入机制使得用户完全不必考虑变量污染，命名空间等方案与之相比相形见绌。

### Node的模块实现

Node在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时也增加了少许自身需要的特性。尽管规范中exports、require和module听起来十分简单，但是Node在实现他们的过程中究竟经历了什么，这个过程需要知晓。

在Node中引入模块，需要经历如下3个步骤。
1. 路径分析
2. 文件定位
3. 编译执行

在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

- 核心模块部分在Node源代码的编译过程中，编译进行了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的

- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢

#### Node的模块加载顺序

1. 优先从缓存加载。Node对引入过的模块会进行缓存，以减少二次引入时的开销。与浏览器缓存不同的是，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。
2. 核心模块，如http、fs、path等。核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经被编译为二进制代码，其加载过程最快。
3. 路径形式的文件模块。以.、..和/开始的标识符，都被当做文件模块来处理。在分析路径模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。
4. 自定义模块。自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。

在Node的所有模块类型中，存在着一种依赖层级关系，即文件模块可能会以来核心模块，核心模块可能会依赖内建模块。通常，不推荐文件模块直接调用内建模块。如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块。

## 异步 I/O
